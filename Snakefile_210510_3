#######################################################################
#######################User-Defined Variables##########################
#######################################################################

#a list of unique prefixes that can be used by Snakemake to differentiate your input sample(s)
SAMPLES=[
#"Oaustraliensis-300131-flowcell-1-SQK-LSK109",
#"Oaustraliensis-300134-flowcell1-SQK-LSK109",
#"Oaustraliensis-300137-flowcell1-SQK-LSK109",
#"Oaustraliensis_keepriver_1g_SQK-LSK109",
#"Oaustraliensis-keepriver-flowcell-2-SQK-LSK109",
#"Oaustraliensis-keepriver-flowcell-3-SQK-LSK109",
#"Omeridionalis-BH-flowcell-1-SQK-LSK109",
#"Osativa_Java_30g_SQK-LSK109",
#"Oaustraliensis_keepriver_flowcell1-2-3",
#"ERR3237140",
#"ERR3850904",
#"SRR10194526",
#"SRR12549534",
#"SRR10377593",
#"SRR12407219",
#"DRR252953",
#"Plantago_pacbio",
#"ERR5421724",
#"SRR9696346",
"DRR196880",
]

#look up reference chloroplast genome of interest on NCBI and insert the accession number, with the version number (.x) appended
ACCESSION="NC_008155.1"

#do not edit this part
REF_GENOME= ACCESSION + ".fasta"

#chloroplast genome size estimate can be obtained from the NCBI search performed above; 'k' denotes kilobases, so 151271 bp for exmaple should be written as "151k" below 
GENOME_SIZE="134k"

#can be map-pb, map-ont, map-hifi, or asm20 - see minimap2 usage for more help: https://github.com/lh3/minimap2
MINIMAP2_READ_TYPE="map-ont"

#can be pacbio-raw, pacbio-corr, pacbio-hifi, nano-raw, or nano-corr - see Flye usage for more help: https://github.com/fenderglass/Flye/blob/flye/docs/USAGE.md
FLYE_READ_TYPE="nano-raw"

THREADS=20

MAX_THREADS = 32

N_BENCHMARKS = 1

#######################################################################
#######################################################################
#######################################################################

singularity:
        "docker://continuumio/miniconda3:4.5.12"
#include:
#        "rules/misc.smk",

#localrules:
#	all,

rule all:
	input:
		expand("chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/ref_10kbp_vs_{sample}_coords.coords",
			cov=["300"],
                        asm=["300"],
                        overlap=["10000"],
                        sample=SAMPLES,
                        ),
		expand("chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/rotated_assembly.fasta",
			cov=["300"],
                        asm=["300"],
                        overlap=["10000"],
                        sample=SAMPLES,
                        ),

rule download_ncbi_long_reads:
	output:
		"files_for_nathan_meeting/test/{sample}_guppy303_all.fastq.gz"
	conda:
		"envs/default.yml"
	threads:
		THREADS
	shell:
		"""
		fastq-dump {wildcards.sample} --gzip -Z > {output}
		cache-mgr --clear >/dev/null 2>&1 
		"""

rule mv_fastq_to_working_dir:
        input:
                "files_for_nathan_meeting/test/{sample}_guppy303_all.fastq.gz"
        output:
                "working_raw_base_calls/{sample}_guppy303_all.fastq.gz"
        shell:
                """
		mv {input} {output}
                """

#rule fastq_to_gz:
#	input:
#		"working_raw_base_calls/{sample}_guppy303_all.fastq"
#	output:
#		"working_raw_base_calls/{sample}_guppy303_all.fastq.gz"
#	conda:
 #               "envs/default.yml"
#	threads:
#		MAX_THREADS
#	shell:
#		"""
#		pigz --stdout --best --processes {threads} {input} > {output}
#		"""

#need to have Biopython installed for NCBI download to work - it's in the default.yml
from snakemake.remote.NCBI import RemoteProvider as NCBIRemoteProvider
NCBI = NCBIRemoteProvider(email="aaron.phillips@adelaide.edu.au") # email required by NCBI to prevent abuse
rule download_chloro_genome:
        input:
                NCBI.remote(REF_GENOME, db="nuccore")
        output:
                "chloro_assembly/reference/{sample}_reference_chloroplast_genome.fasta",
	shell:
                """
		cat {input} > {output} #chloro_assembly/reference/{wildcards.sample}_reference_chloroplast_genome.fasta
                """

#cat {input} | head -n 1 | cut -d " " -f 1 > {output}
rule get_ref_chloro_genome_header:
	input:
		"chloro_assembly/reference/{sample}_reference_chloroplast_genome.fasta"
	output:
		temp("chloro_assembly/reference/{sample}_reference_chloroplast_header.txt")
	shell:
		"""
		head -n 1 {input} > {output}
		"""

rule get_ref_chloro_genome_NCBI_name:
	input:
		"chloro_assembly/reference/{sample}_reference_chloroplast_header.txt"
	output:
		temp("chloro_assembly/reference/{sample}_reference_chloroplast_name.txt")
	shell:
		"""
		cut -d " " -f 1 {input} > {output}
		"""

rule get_ref_chloro_genome_seq:
	input:
		"chloro_assembly/reference/{sample}_reference_chloroplast_genome.fasta",
	output:
		seq=temp("chloro_assembly/reference/{sample}_reference_chloroplast_seq.txt"),
	shell:
		"""
		cat {input} | tail -n+2 > {output.seq}
		"""

rule make_working_ref_chloro_genome:
	input:
		name="chloro_assembly/reference/{sample}_reference_chloroplast_name.txt",
		seq="chloro_assembly/reference/{sample}_reference_chloroplast_seq.txt",
	output:
		name=temp("chloro_assembly/reference/{sample}_reference_chloroplast_genome_NCBI_name.fasta"),
	shell:
		"""
		cat {input.name} {input.seq} > {output.name}
		"""

rule make_circular_chloro_ref_genome:
	input:
		"chloro_assembly/reference/{sample}_reference_chloroplast_genome_NCBI_name.fasta"
	output:
		"chloro_assembly/reference/{sample}_circular_chloro_reference.fasta"
	shell:
		"""
		touch {output}
                for j in {input} #chloro_assembly/reference/{wildcards.sample}_reference_chloroplast_genome_NCBI_name.fasta
                do
                        echo ${{j}}
                        grep '^>' ${{j}} >> {output}
                        grep -v '^>' ${{j}} > temp
                        tr -d '\\n' < temp > temp2
                        cat temp2 >> {output}
                        cat temp2 >> {output}
                        sed -i -e '$a\\\' {output}
                done
		"""

rule minimap2_plastid:
	input:
		PLASTIDTABLE = "chloro_assembly/reference/{sample}_circular_chloro_reference.fasta",
		QC_FASTQ = "working_raw_base_calls/{sample}_guppy303_all.fastq.gz",
	output:
		temp("chloro_assembly/{sample}_chloro_mapped_reads.sam"),
	threads:
		15
	conda:
		"envs/mapping_reads.yml"
	params:
		read_type=MINIMAP2_READ_TYPE
	shell:
		"""
		minimap2 -ax {params.read_type} -t {threads} {input.PLASTIDTABLE} {input.QC_FASTQ} > {output}
		"""

#extract reads that map to chloro
rule samtools_minimap2_plastid:
	input:
		"chloro_assembly/{sample}_chloro_mapped_reads.sam"
	output:
		temp("chloro_assembly/{sample}_chloro_only_mapped_reads.sam")
	threads:
		15
	conda:
		"envs/mapping_reads.yml"
	shell:
		"""
		samtools view -F 4 -@ {threads} {input} > {output}
		"""

#get chloro read names
rule extract_plastid_read_names:
	input:
		"chloro_assembly/{sample}_chloro_only_mapped_reads.sam"
	output:
		temp("chloro_assembly/{sample}_chloro_read_names.txt"),
	conda:
		"envs/mapping_reads.yml"
	wildcard_constraints:
		#sample = "[^_unique]+",
		sample = '|'.join([x for x in SAMPLES]),
	shell:
		"""
		awk '{{print $1}}' {input} > {output}
		"""

#generates list of unique read names that map to plastid (chloro and/or mito genomes)
rule sort_unique_mapped_read_names:
	input:
		"chloro_assembly/{sample}_chloro_read_names.txt"
	output:
		temp("chloro_assembly/{sample}_unique_chloro_read_names.txt")
	conda:
		"envs/default.yml"
	shell:
		"""
		sort {input} | uniq > {output}
		"""

rule pull_unique_reads:
	input:
		QC_FASTQ2 = "working_raw_base_calls/{sample}_guppy303_all.fastq.gz",
		UNIQUE_CHLORO_READS = "chloro_assembly/{sample}_unique_chloro_read_names.txt"
	output:
		"chloro_assembly/{sample}_chloro_reads.fastq"
	conda:
		"envs/mapping_reads.yml"
	shell:
		"""
		seqtk subseq {input.QC_FASTQ2} {input.UNIQUE_CHLORO_READS} > {output}
		"""

#need to subset reads, otherwise the mem requirements of Flye are too huge (when cov is in 10's of thousands with raw reads)
rule subset_reads_for_x_coverage:
	input:
		"chloro_assembly/{sample}_chloro_reads.fastq",
	output:
		temp("chloro_assembly/{sample}_chloro_reads_subsampled_{cov}x_cov.fastq"),
	conda:
		"envs/subset_reads_for_x_coverage.yml"
	params:
                genome_size=GENOME_SIZE
	shell:
		"""
		rasusa --input {input} --output {output} --coverage {wildcards.cov} --genome-size {params.genome_size}
		"""

rule raw_flye_chloro_assembly:
	input:
		"chloro_assembly/{sample}_chloro_reads_subsampled_{cov}x_cov.fastq"
	output:
		"chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/assembly.fasta"
	conda:
		"envs/genome_assembly.yml"
	threads:
		20
	params:
		read_type=FLYE_READ_TYPE,
		genome_size=GENOME_SIZE,
		outdir = "chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}"
	shell:
		"""
		flye --{params.read_type} {input} --asm-coverage {wildcards.asm} --min-overlap {wildcards.overlap} --out-dir {params.outdir} --genome-size {params.genome_size}  --threads {threads}
		"""

#'rotate' the assembled chloroplast genome to match the expected orientation: https://github.com/mrmckain/Fast-Plast/issues/22

rule get_chloro_ref_name_only:
	input:
		"chloro_assembly/reference/{sample}_reference_chloroplast_name.txt"
	output:
		temp("chloro_assembly/reference/{sample}_reference_chloroplast_name_2.txt")
	shell:
		"""
		sed -e 's/>//' {input} > {output}
		"""

rule create_bed_file_for_10kbp_chloro_region:
	input:
		"chloro_assembly/reference/{sample}_reference_chloroplast_name_2.txt"
	output:
		temp("chloro_assembly/reference/{sample}_reference_chloroplast_genome_first_10kbp.bed")
	shell:
		"""
		echo "$(<{input} )" 0 10000 > {output}
		"""

rule extract_first_10kbp_from_ref:
	input:
		fasta="chloro_assembly/reference/{sample}_circular_chloro_reference.fasta",
		bed="chloro_assembly/reference/{sample}_reference_chloroplast_genome_first_10kbp.bed"
	output:
		temp("chloro_assembly/reference/{sample}_reference_chloroplast_genome_first_10kbp.fasta")
	conda:
		"envs/genome_assembly.yml"
	shell:
		"""
		seqtk subseq {input.fasta} {input.bed} > {output}
		"""

rule align_chloro_to_ref:
	input:
		query ="chloro_assembly/reference/{sample}_reference_chloroplast_genome_first_10kbp.fasta",
		ref="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/assembly.fasta"
	output:
		sample_vs_ref="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/{sample}_vs_ref_10kbp.delta",
	conda:
		"envs/genome_assembly.yml"
	params:
		prefix1="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/{sample}_vs_ref_10kbp"
	shell:
		"""
		nucmer --maxmatch --prefix={params.prefix1} {input.query} {input.ref}
		"""

rule align_ref_to_chloro:
        input:
                query ="chloro_assembly/reference/{sample}_reference_chloroplast_genome_first_10kbp.fasta",
                ref="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/assembly.fasta"
        output:
                ref_vs_sample="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/ref_10kbp_vs_{sample}.delta"
        conda:
                "envs/genome_assembly.yml"
        params:
                prefix="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/ref_10kbp_vs_{sample}"
        shell:
                """
                nucmer --maxmatch --prefix={params.prefix} {input.ref} {input.query}
                """

rule get_alignment_coords:
	input:
		"chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/{sample}_vs_ref_10kbp.delta"
	output:
		"chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/{sample}_vs_ref_10kbp_coords.coords"
	conda:
		"envs/genome_assembly.yml"
	shell:
		"""
		show-coords -THrdc {input} > {output}
		"""

rule get_alignment_coords_2:
        input:
                "chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/ref_10kbp_vs_{sample}.delta"
        output:
                "chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/ref_10kbp_vs_{sample}_coords.coords"
        conda:
                "envs/genome_assembly.yml"
        shell:
                """
                show-coords -THrdc {input} > {output}
                """

rule extract_contig_name:
	input:
		"chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/assembly.fasta",
	output:
		"chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/rotated_assembly_name.fasta"
	shell:
		"""
		grep '^>' {input} > {output}
		"""

rule extract_contig_seq:
	input:
		"chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/assembly.fasta"
	output:
		"chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/temp.fasta"
	shell:
		"""
		grep -v '^>' {input} | tr -d '\\n' > {output}
		"""

rule rotate_chloro_genomes:
	input:
		chloro="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/assembly.fasta",
		coords="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/{sample}_vs_ref_10kbp_coords.coords"
	output:
		rotated="chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/rotated_assembly.fasta",
		temp=temp("chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/temp.fasta"),
		start=temp("chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/genome.start.fasta"),
		end=temp("chloro_assembly/{sample}_flye_assembly/cov-{cov}_asm-{asm}_ovlp-{overlap}/genome_end.fasta")
	shell:
		"""
		best="$(cut -f6 {input.coords} | sort -hr | head -n 1)"
		start="$(sort -k6,6hr {input.coords} | head -n 1 | cut -f3 || true)"
		#start="$(grep $best {input.coords} | cut -f3)"
		grep '^>' {input.chloro} > {output.rotated} 
  		grep -v '^>' {input.chloro} | tr -d '\\n' > {output.temp}
		cut -c ${{start}}- {output.temp} > {output.start}
		cut -c -$[${{start}}-1] {output.temp} > {output.end}
		cat {output.start} {output.end} | tr -d '\\n' >> {output.rotated} 
		"""

##check quality of chloroplast assembly:
#BUSCO
#LAI
